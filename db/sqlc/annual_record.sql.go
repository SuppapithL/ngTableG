// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: annual_record.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignQuotaPlanToAllUsers = `-- name: AssignQuotaPlanToAllUsers :exec
WITH user_list AS (
    SELECT id FROM users
)
UPDATE annual_records
SET 
    quota_plan_id = $1,
    updated_at = NOW()
WHERE year = $2
`

type AssignQuotaPlanToAllUsersParams struct {
	QuotaPlanID pgtype.Int4 `json:"quotaPlanId"`
	Year        int32       `json:"year"`
}

// Update existing records
func (q *Queries) AssignQuotaPlanToAllUsers(ctx context.Context, arg AssignQuotaPlanToAllUsersParams) error {
	_, err := q.db.Exec(ctx, assignQuotaPlanToAllUsers, arg.QuotaPlanID, arg.Year)
	return err
}

const createAnnualRecord = `-- name: CreateAnnualRecord :one
INSERT INTO annual_records (
  user_id,
  year,
  quota_plan_id,
  rollover_vacation_day,
  used_vacation_day,
  used_sick_leave_day,
  worked_on_holiday_day,
  worked_day,
  used_medical_expense_baht
) VALUES (
  $1, $2, $3, $4, 
  $5, $6, $7, 
  $8, $9
) RETURNING id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type CreateAnnualRecordParams struct {
	UserID                 int32          `json:"userId"`
	Year                   int32          `json:"year"`
	QuotaPlanID            pgtype.Int4    `json:"quotaPlanId"`
	RolloverVacationDay    pgtype.Numeric `json:"rolloverVacationDay"`
	UsedVacationDay        pgtype.Numeric `json:"usedVacationDay"`
	UsedSickLeaveDay       pgtype.Numeric `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay     pgtype.Numeric `json:"workedOnHolidayDay"`
	WorkedDay              pgtype.Numeric `json:"workedDay"`
	UsedMedicalExpenseBaht pgtype.Numeric `json:"usedMedicalExpenseBaht"`
}

func (q *Queries) CreateAnnualRecord(ctx context.Context, arg CreateAnnualRecordParams) (AnnualRecord, error) {
	row := q.db.QueryRow(ctx, createAnnualRecord,
		arg.UserID,
		arg.Year,
		arg.QuotaPlanID,
		arg.RolloverVacationDay,
		arg.UsedVacationDay,
		arg.UsedSickLeaveDay,
		arg.WorkedOnHolidayDay,
		arg.WorkedDay,
		arg.UsedMedicalExpenseBaht,
	)
	var i AnnualRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createNextYearAnnualRecords = `-- name: CreateNextYearAnnualRecords :many
WITH user_list AS (
    SELECT id FROM users
),
default_quota_plan AS (
    SELECT id 
    FROM quota_plans 
    WHERE year = $1 AND plan_name = 'Default'
    LIMIT 1
),
current_year_records AS (
    SELECT 
        ar.user_id,
        ar.used_vacation_day,
        ar.worked_on_holiday_day,
        qp.quota_vacation_day
    FROM annual_records ar
    LEFT JOIN quota_plans qp ON ar.quota_plan_id = qp.id
    WHERE ar.year = $2
),
rollover_calculation AS (
    SELECT 
        ul.id AS user_id,
        $1 AS year,
        (SELECT id FROM default_quota_plan) AS quota_plan_id,
        COALESCE(
            GREATEST(
                COALESCE(cyr.quota_vacation_day, 0) + 
                COALESCE(cyr.worked_on_holiday_day, 0) - 
                COALESCE(cyr.used_vacation_day, 0),
                0
            ),
            0
        ) AS rollover_vacation_day,
        0 AS used_vacation_day,
        0 AS used_sick_leave_day,
        0 AS worked_on_holiday_day,
        0 AS worked_day,
        0 AS used_medical_expense_baht
    FROM user_list ul
    LEFT JOIN current_year_records cyr ON ul.id = cyr.user_id
)
INSERT INTO annual_records (
    user_id,
    year,
    quota_plan_id,
    rollover_vacation_day,
    used_vacation_day,
    used_sick_leave_day,
    worked_on_holiday_day,
    worked_day,
    used_medical_expense_baht
)
SELECT 
    user_id,
    year,
    quota_plan_id,
    rollover_vacation_day,
    used_vacation_day,
    used_sick_leave_day,
    worked_on_holiday_day,
    worked_day,
    used_medical_expense_baht
FROM rollover_calculation
WHERE NOT EXISTS (
    SELECT 1 FROM annual_records 
    WHERE annual_records.user_id = rollover_calculation.user_id 
    AND annual_records.year = $1
)
RETURNING id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type CreateNextYearAnnualRecordsParams struct {
	NextYear int32 `json:"nextYear"`
	ThisYear int32 `json:"thisYear"`
}

func (q *Queries) CreateNextYearAnnualRecords(ctx context.Context, arg CreateNextYearAnnualRecordsParams) ([]AnnualRecord, error) {
	rows, err := q.db.Query(ctx, createNextYearAnnualRecords, arg.NextYear, arg.ThisYear)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnnualRecord{}
	for rows.Next() {
		var i AnnualRecord
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Year,
			&i.QuotaPlanID,
			&i.RolloverVacationDay,
			&i.UsedVacationDay,
			&i.UsedSickLeaveDay,
			&i.WorkedOnHolidayDay,
			&i.WorkedDay,
			&i.UsedMedicalExpenseBaht,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteAnnualRecord = `-- name: DeleteAnnualRecord :exec
DELETE FROM annual_records
WHERE id = $1
`

func (q *Queries) DeleteAnnualRecord(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteAnnualRecord, id)
	return err
}

const getAnnualRecord = `-- name: GetAnnualRecord :one
SELECT id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at FROM annual_records
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAnnualRecord(ctx context.Context, id int32) (AnnualRecord, error) {
	row := q.db.QueryRow(ctx, getAnnualRecord, id)
	var i AnnualRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAnnualRecordByUserAndYear = `-- name: GetAnnualRecordByUserAndYear :one
SELECT ar.id, ar.user_id, ar.year, ar.quota_plan_id, ar.rollover_vacation_day, ar.used_vacation_day, ar.used_sick_leave_day, ar.worked_on_holiday_day, ar.worked_day, ar.used_medical_expense_baht, ar.created_at, ar.updated_at, qp.quota_vacation_day, qp.quota_medical_expense_baht
FROM annual_records ar
LEFT JOIN quota_plans qp ON ar.quota_plan_id = qp.id
WHERE ar.user_id = $1 AND ar.year = $2 LIMIT 1
`

type GetAnnualRecordByUserAndYearParams struct {
	UserID int32 `json:"userId"`
	Year   int32 `json:"year"`
}

type GetAnnualRecordByUserAndYearRow struct {
	ID                      int32              `json:"id"`
	UserID                  int32              `json:"userId"`
	Year                    int32              `json:"year"`
	QuotaPlanID             pgtype.Int4        `json:"quotaPlanId"`
	RolloverVacationDay     pgtype.Numeric     `json:"rolloverVacationDay"`
	UsedVacationDay         pgtype.Numeric     `json:"usedVacationDay"`
	UsedSickLeaveDay        pgtype.Numeric     `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay      pgtype.Numeric     `json:"workedOnHolidayDay"`
	WorkedDay               pgtype.Numeric     `json:"workedDay"`
	UsedMedicalExpenseBaht  pgtype.Numeric     `json:"usedMedicalExpenseBaht"`
	CreatedAt               pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt               pgtype.Timestamptz `json:"updatedAt"`
	QuotaVacationDay        pgtype.Numeric     `json:"quotaVacationDay"`
	QuotaMedicalExpenseBaht pgtype.Numeric     `json:"quotaMedicalExpenseBaht"`
}

func (q *Queries) GetAnnualRecordByUserAndYear(ctx context.Context, arg GetAnnualRecordByUserAndYearParams) (GetAnnualRecordByUserAndYearRow, error) {
	row := q.db.QueryRow(ctx, getAnnualRecordByUserAndYear, arg.UserID, arg.Year)
	var i GetAnnualRecordByUserAndYearRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.QuotaVacationDay,
		&i.QuotaMedicalExpenseBaht,
	)
	return i, err
}

const listAnnualRecordsByUser = `-- name: ListAnnualRecordsByUser :many
SELECT ar.id, ar.user_id, ar.year, ar.quota_plan_id, ar.rollover_vacation_day, ar.used_vacation_day, ar.used_sick_leave_day, ar.worked_on_holiday_day, ar.worked_day, ar.used_medical_expense_baht, ar.created_at, ar.updated_at, qp.quota_vacation_day, qp.quota_medical_expense_baht
FROM annual_records ar
LEFT JOIN quota_plans qp ON ar.quota_plan_id = qp.id
WHERE ar.user_id = $1
ORDER BY ar.year DESC
`

type ListAnnualRecordsByUserRow struct {
	ID                      int32              `json:"id"`
	UserID                  int32              `json:"userId"`
	Year                    int32              `json:"year"`
	QuotaPlanID             pgtype.Int4        `json:"quotaPlanId"`
	RolloverVacationDay     pgtype.Numeric     `json:"rolloverVacationDay"`
	UsedVacationDay         pgtype.Numeric     `json:"usedVacationDay"`
	UsedSickLeaveDay        pgtype.Numeric     `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay      pgtype.Numeric     `json:"workedOnHolidayDay"`
	WorkedDay               pgtype.Numeric     `json:"workedDay"`
	UsedMedicalExpenseBaht  pgtype.Numeric     `json:"usedMedicalExpenseBaht"`
	CreatedAt               pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt               pgtype.Timestamptz `json:"updatedAt"`
	QuotaVacationDay        pgtype.Numeric     `json:"quotaVacationDay"`
	QuotaMedicalExpenseBaht pgtype.Numeric     `json:"quotaMedicalExpenseBaht"`
}

func (q *Queries) ListAnnualRecordsByUser(ctx context.Context, userID int32) ([]ListAnnualRecordsByUserRow, error) {
	rows, err := q.db.Query(ctx, listAnnualRecordsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAnnualRecordsByUserRow{}
	for rows.Next() {
		var i ListAnnualRecordsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Year,
			&i.QuotaPlanID,
			&i.RolloverVacationDay,
			&i.UsedVacationDay,
			&i.UsedSickLeaveDay,
			&i.WorkedOnHolidayDay,
			&i.WorkedDay,
			&i.UsedMedicalExpenseBaht,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuotaVacationDay,
			&i.QuotaMedicalExpenseBaht,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnnualRecordsByYear = `-- name: ListAnnualRecordsByYear :many
SELECT ar.id, ar.user_id, ar.year, ar.quota_plan_id, ar.rollover_vacation_day, ar.used_vacation_day, ar.used_sick_leave_day, ar.worked_on_holiday_day, ar.worked_day, ar.used_medical_expense_baht, ar.created_at, ar.updated_at, qp.quota_vacation_day, qp.quota_medical_expense_baht
FROM annual_records ar
LEFT JOIN quota_plans qp ON ar.quota_plan_id = qp.id
WHERE ar.year = $1
ORDER BY ar.user_id
`

type ListAnnualRecordsByYearRow struct {
	ID                      int32              `json:"id"`
	UserID                  int32              `json:"userId"`
	Year                    int32              `json:"year"`
	QuotaPlanID             pgtype.Int4        `json:"quotaPlanId"`
	RolloverVacationDay     pgtype.Numeric     `json:"rolloverVacationDay"`
	UsedVacationDay         pgtype.Numeric     `json:"usedVacationDay"`
	UsedSickLeaveDay        pgtype.Numeric     `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay      pgtype.Numeric     `json:"workedOnHolidayDay"`
	WorkedDay               pgtype.Numeric     `json:"workedDay"`
	UsedMedicalExpenseBaht  pgtype.Numeric     `json:"usedMedicalExpenseBaht"`
	CreatedAt               pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt               pgtype.Timestamptz `json:"updatedAt"`
	QuotaVacationDay        pgtype.Numeric     `json:"quotaVacationDay"`
	QuotaMedicalExpenseBaht pgtype.Numeric     `json:"quotaMedicalExpenseBaht"`
}

func (q *Queries) ListAnnualRecordsByYear(ctx context.Context, year int32) ([]ListAnnualRecordsByYearRow, error) {
	rows, err := q.db.Query(ctx, listAnnualRecordsByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAnnualRecordsByYearRow{}
	for rows.Next() {
		var i ListAnnualRecordsByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Year,
			&i.QuotaPlanID,
			&i.RolloverVacationDay,
			&i.UsedVacationDay,
			&i.UsedSickLeaveDay,
			&i.WorkedOnHolidayDay,
			&i.WorkedDay,
			&i.UsedMedicalExpenseBaht,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuotaVacationDay,
			&i.QuotaMedicalExpenseBaht,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAnnualRecord = `-- name: UpdateAnnualRecord :one
UPDATE annual_records
SET 
  quota_plan_id = COALESCE($1, quota_plan_id),
  rollover_vacation_day = COALESCE($2, rollover_vacation_day),
  used_vacation_day = COALESCE($3, used_vacation_day),
  used_sick_leave_day = COALESCE($4, used_sick_leave_day),
  worked_on_holiday_day = COALESCE($5, worked_on_holiday_day),
  worked_day = COALESCE($6, worked_day),
  used_medical_expense_baht = COALESCE($7, used_medical_expense_baht),
  updated_at = NOW()
WHERE user_id = $8 AND year = $9
RETURNING id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type UpdateAnnualRecordParams struct {
	QuotaPlanID            pgtype.Int4    `json:"quotaPlanId"`
	RolloverVacationDay    pgtype.Numeric `json:"rolloverVacationDay"`
	UsedVacationDay        pgtype.Numeric `json:"usedVacationDay"`
	UsedSickLeaveDay       pgtype.Numeric `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay     pgtype.Numeric `json:"workedOnHolidayDay"`
	WorkedDay              pgtype.Numeric `json:"workedDay"`
	UsedMedicalExpenseBaht pgtype.Numeric `json:"usedMedicalExpenseBaht"`
	UserID                 int32          `json:"userId"`
	Year                   int32          `json:"year"`
}

func (q *Queries) UpdateAnnualRecord(ctx context.Context, arg UpdateAnnualRecordParams) (AnnualRecord, error) {
	row := q.db.QueryRow(ctx, updateAnnualRecord,
		arg.QuotaPlanID,
		arg.RolloverVacationDay,
		arg.UsedVacationDay,
		arg.UsedSickLeaveDay,
		arg.WorkedOnHolidayDay,
		arg.WorkedDay,
		arg.UsedMedicalExpenseBaht,
		arg.UserID,
		arg.Year,
	)
	var i AnnualRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAnnualRecordForUser = `-- name: UpsertAnnualRecordForUser :one
INSERT INTO annual_records (
    user_id,
    year,
    quota_plan_id,
    rollover_vacation_day,
    used_vacation_day,
    used_sick_leave_day,
    worked_on_holiday_day,
    worked_day,
    used_medical_expense_baht
)
VALUES (
    $1,
    $2,
    $3,
    COALESCE($4, 0),
    COALESCE($5, 0),
    COALESCE($6, 0),
    COALESCE($7, 0),
    COALESCE($8, 0),
    COALESCE($9, 0)
)
ON CONFLICT (user_id, year) DO UPDATE SET
    quota_plan_id = $3,
    updated_at = NOW()
RETURNING id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type UpsertAnnualRecordForUserParams struct {
	UserID                 int32       `json:"userId"`
	Year                   int32       `json:"year"`
	QuotaPlanID            pgtype.Int4 `json:"quotaPlanId"`
	RolloverVacationDay    interface{} `json:"rolloverVacationDay"`
	UsedVacationDay        interface{} `json:"usedVacationDay"`
	UsedSickLeaveDay       interface{} `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay     interface{} `json:"workedOnHolidayDay"`
	WorkedDay              interface{} `json:"workedDay"`
	UsedMedicalExpenseBaht interface{} `json:"usedMedicalExpenseBaht"`
}

func (q *Queries) UpsertAnnualRecordForUser(ctx context.Context, arg UpsertAnnualRecordForUserParams) (AnnualRecord, error) {
	row := q.db.QueryRow(ctx, upsertAnnualRecordForUser,
		arg.UserID,
		arg.Year,
		arg.QuotaPlanID,
		arg.RolloverVacationDay,
		arg.UsedVacationDay,
		arg.UsedSickLeaveDay,
		arg.WorkedOnHolidayDay,
		arg.WorkedDay,
		arg.UsedMedicalExpenseBaht,
	)
	var i AnnualRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
