// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: annual_record_sync.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const syncAllAnnualRecordsByYear = `-- name: SyncAllAnnualRecordsByYear :many
WITH user_stats AS (
    SELECT 
        u.id AS user_id,
        COALESCE(SUM(CASE WHEN ll.type = 'vacation' THEN 1 ELSE 0 END), 0) AS vacation_days,
        COALESCE(SUM(CASE WHEN ll.type = 'sick' THEN 1 ELSE 0 END), 0) AS sick_days,
        COALESCE((SELECT SUM(tl.worked_day) 
                  FROM task_logs tl 
                  WHERE tl.created_by_user_id = u.id 
                  AND EXTRACT(YEAR FROM tl.worked_date) = $1), 0) AS total_worked_days,
        COALESCE((SELECT SUM(CASE WHEN tl.is_work_on_holiday = true THEN tl.worked_day ELSE 0 END) 
                  FROM task_logs tl 
                  WHERE tl.created_by_user_id = u.id 
                  AND EXTRACT(YEAR FROM tl.worked_date) = $1), 0) AS holiday_worked_days
    FROM users u
    LEFT JOIN leave_logs ll ON u.id = ll.user_id AND EXTRACT(YEAR FROM ll.date) = $1
    GROUP BY u.id
)
UPDATE annual_records ar
SET 
    used_vacation_day = us.vacation_days,
    used_sick_leave_day = us.sick_days,
    worked_day = us.total_worked_days,
    worked_on_holiday_day = us.holiday_worked_days,
    updated_at = NOW()
FROM user_stats us
WHERE ar.user_id = us.user_id AND ar.year = $1
RETURNING us.user_id, vacation_days, sick_days, total_worked_days, holiday_worked_days, id, ar.user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type SyncAllAnnualRecordsByYearRow struct {
	UserID                 int32              `json:"userId"`
	VacationDays           interface{}        `json:"vacationDays"`
	SickDays               interface{}        `json:"sickDays"`
	TotalWorkedDays        interface{}        `json:"totalWorkedDays"`
	HolidayWorkedDays      interface{}        `json:"holidayWorkedDays"`
	ID                     int32              `json:"id"`
	UserID_2               int32              `json:"userId2"`
	Year                   int32              `json:"year"`
	QuotaPlanID            pgtype.Int4        `json:"quotaPlanId"`
	RolloverVacationDay    pgtype.Numeric     `json:"rolloverVacationDay"`
	UsedVacationDay        pgtype.Numeric     `json:"usedVacationDay"`
	UsedSickLeaveDay       pgtype.Numeric     `json:"usedSickLeaveDay"`
	WorkedOnHolidayDay     pgtype.Numeric     `json:"workedOnHolidayDay"`
	WorkedDay              pgtype.Numeric     `json:"workedDay"`
	UsedMedicalExpenseBaht pgtype.Numeric     `json:"usedMedicalExpenseBaht"`
	CreatedAt              pgtype.Timestamptz `json:"createdAt"`
	UpdatedAt              pgtype.Timestamptz `json:"updatedAt"`
}

// This query synchronizes all annual records for a specific year
func (q *Queries) SyncAllAnnualRecordsByYear(ctx context.Context, year int32) ([]SyncAllAnnualRecordsByYearRow, error) {
	rows, err := q.db.Query(ctx, syncAllAnnualRecordsByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SyncAllAnnualRecordsByYearRow{}
	for rows.Next() {
		var i SyncAllAnnualRecordsByYearRow
		if err := rows.Scan(
			&i.UserID,
			&i.VacationDays,
			&i.SickDays,
			&i.TotalWorkedDays,
			&i.HolidayWorkedDays,
			&i.ID,
			&i.UserID_2,
			&i.Year,
			&i.QuotaPlanID,
			&i.RolloverVacationDay,
			&i.UsedVacationDay,
			&i.UsedSickLeaveDay,
			&i.WorkedOnHolidayDay,
			&i.WorkedDay,
			&i.UsedMedicalExpenseBaht,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncAnnualRecordVacationDays = `-- name: SyncAnnualRecordVacationDays :one
WITH vacation_days AS (
    SELECT 
        SUM(CASE WHEN ll.type = 'vacation' THEN 1 ELSE 0 END) AS vacation_count,
        SUM(CASE WHEN ll.type = 'sick' THEN 1 ELSE 0 END) AS sick_count
    FROM leave_logs ll
    WHERE ll.user_id = $1 AND EXTRACT(YEAR FROM ll.date) = $2
)
UPDATE annual_records ar
SET 
    used_vacation_day = COALESCE((SELECT vacation_count FROM vacation_days), 0),
    used_sick_leave_day = COALESCE((SELECT sick_count FROM vacation_days), 0),
    updated_at = NOW()
WHERE ar.user_id = $1 AND ar.year = $2
RETURNING id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type SyncAnnualRecordVacationDaysParams struct {
	UserID int32 `json:"userId"`
	Year   int32 `json:"year"`
}

// This query synchronizes the used vacation days and sick leave days for a specific user and year
func (q *Queries) SyncAnnualRecordVacationDays(ctx context.Context, arg SyncAnnualRecordVacationDaysParams) (AnnualRecord, error) {
	row := q.db.QueryRow(ctx, syncAnnualRecordVacationDays, arg.UserID, arg.Year)
	var i AnnualRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const syncAnnualRecordWorkDays = `-- name: SyncAnnualRecordWorkDays :one
WITH work_days AS (
    SELECT 
        SUM(tl.worked_day) AS total_worked_days,
        SUM(CASE WHEN tl.is_work_on_holiday = true THEN tl.worked_day ELSE 0 END) AS holiday_worked_days
    FROM task_logs tl
    WHERE tl.created_by_user_id = $1 AND EXTRACT(YEAR FROM tl.worked_date) = $2
)
UPDATE annual_records ar
SET 
    worked_day = COALESCE((SELECT total_worked_days FROM work_days), 0),
    worked_on_holiday_day = COALESCE((SELECT holiday_worked_days FROM work_days), 0),
    updated_at = NOW()
WHERE ar.user_id = $1 AND ar.year = $2
RETURNING id, user_id, year, quota_plan_id, rollover_vacation_day, used_vacation_day, used_sick_leave_day, worked_on_holiday_day, worked_day, used_medical_expense_baht, created_at, updated_at
`

type SyncAnnualRecordWorkDaysParams struct {
	UserID int32 `json:"userId"`
	Year   int32 `json:"year"`
}

// This query synchronizes the worked days and worked on holiday days for a specific user and year
func (q *Queries) SyncAnnualRecordWorkDays(ctx context.Context, arg SyncAnnualRecordWorkDaysParams) (AnnualRecord, error) {
	row := q.db.QueryRow(ctx, syncAnnualRecordWorkDays, arg.UserID, arg.Year)
	var i AnnualRecord
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Year,
		&i.QuotaPlanID,
		&i.RolloverVacationDay,
		&i.UsedVacationDay,
		&i.UsedSickLeaveDay,
		&i.WorkedOnHolidayDay,
		&i.WorkedDay,
		&i.UsedMedicalExpenseBaht,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
